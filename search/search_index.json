{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Autotyping","text":"<p><code>django-autotyping</code> enhances your developing experience with Django by providing accurate type hints, without the need for a custom IDE or mypy plugin:</p> <ul> <li>Generates custom type stubs based on the current state of your Django application, enhancing your development experience by providing auto-completions and accurate type checking.</li> <li>Automatically add explicit type hints to your source code when type stubs are not enough.</li> </ul> <p>To understand the why and how, you can refer to the context section.</p> <p><code>django-autotyping</code> is built with LibCST.</p> <p> </p> A live demo <p>Still in development</p> <p>This project is still work in progress. It is meant to work with <code>django-stubs</code>, but some improvements and changes are probably going to be implemented in the stub definitions, and could potentially require some changes to the generated stubs.</p>"},{"location":"#installation","title":"Installation","text":"<p>Through <code>pip</code>:</p> <pre><code>pip install django-autotyping\n</code></pre> <p>To make use of the dynamic stubs feature, you will also need to install <code>django-stubs</code>:</p> <pre><code>pip install django-stubs\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>As any Django application, you will need to add <code>django_autotyping</code> to your <code>INSTALLED_APPS</code> (preferably in your development or local settings, if you already have them separated).</p> <p>The application is configurable through the <code>AUTOTYPING</code> dict:</p> <pre><code>AUTOTYPING = {\n    \"STUBS_GENERATION\": {\n        \"LOCAL_STUBS_DIR\": Path(BASE_DIR, \"typings\"),\n    }\n}\n</code></pre> Type checking configuration <p>To get typing and auto-completion support, you can make use of the <code>AutotypingSettingsDict</code> helper:</p> <pre><code>from django_autotyping.typing import AutotypingSettingsDict\n\nAUTOTYPING: AutotypingSettingsDict = {\n    ...\n}\n</code></pre> <p><code>django-autotyping</code> provides several linting rules, identified with the pattern <code>DJA00X</code> or <code>DJAS00X</code>. Rules can be disabled using the <code>IGNORE</code> setting value.</p> <p>For a complete list of available configuration values, refer to the usage section of dynamic stubs and explicit type hints.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#050-2024-02-18","title":"0.5.0 (2024-02-18)","text":"<p>This release brings basic support for template loading functions (e.g. <code>render_to_string</code>).</p> <ul> <li>Fixed some typos in readme and docstrings (#50)</li> <li>Fixes and tests for <code>DJAS002/3</code> (#53)</li> <li>Add support for template loading functions (#56)</li> <li>Remove outdated VSCode limitation in docs (#57)</li> </ul>"},{"location":"changelog/#040-2024-02-04","title":"0.4.0 (2024-02-04)","text":"<p>This release brings improvements to the model creation related comemod: - <code>DJAS002</code> was refactored and now provides better types for fields (instead of <code>Any</code>).   It is now split into two rules: <code>DJAS002</code> and <code>DJAS003</code>.</p> <ul> <li>Fix README rendering for PyPI (#43)</li> <li>Add draft implementation for <code>call_command</code> overloads (#45)</li> <li>Refactor and improve support for model creation (#46)</li> <li>Update to <code>ruff==0.2.0</code>, add new rules (#47)</li> <li>Typos and updates to docs (#48)</li> </ul>"},{"location":"changelog/#030-2024-01-23","title":"0.3.0 (2024-01-23)","text":"<ul> <li>Add more tests for DJAS001, test DJAS010 (#34)</li> <li>Add support for custom user model (#35)</li> <li>Add animated example (#38)</li> <li>Add support for settings typing (#37)</li> </ul>"},{"location":"changelog/#020-2024-01-15","title":"0.2.0 (2024-01-15)","text":"<ul> <li>Complete refactor of the library (no post migrate signal, management commands)</li> <li>Added tests, docs</li> </ul>"},{"location":"changelog/#010-2023-12-17","title":"0.1.0 (2023-12-17)","text":"<ul> <li>Add support for custom dynamic stubs</li> <li>Support duplicate models across apps</li> <li>Various improvements to the codebase</li> </ul>"},{"location":"changelog/#001-2023-12-05","title":"0.0.1 (2023-12-05)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"context/","title":"Context","text":"<p>Info</p> <p>This section expands on this article, which goes into more technical details.</p> <p>This section describes how <code>django-autotyping</code> is able to provide features working with any type checker and without having to manually annotate your code.</p>"},{"location":"context/#the-current-state-of-typing-with-django","title":"The current state of typing with Django","text":"<p>Django being created way before type hints were a thing in Python, it wasn\u2019t designed with typing support in mind. For this reason, external type stubs are maintained by the TypedDjango organization.</p> <p>By installing <code>django-stubs</code>, you will be able to enforce type checking in your Django project, and also benefit from a nicer development experience assuming you are using a LSP implementation in your IDE.</p> <p>However, it is sometimes not possible to support all the dynamic features provided by Django at runtime.</p> <p>The most common (and probably annoying) example appears when dealing with models and foreign fields:</p> <pre><code>from django.db import models\n\nclass Blog(models.Model): ...\n\nclass BlogPost(models.Model):\n    name = models.CharField(\n        max_length=255,\n    )\n    blog = models.ForeignKey(\n        to=\"Blog\",\n        on_delete=models.CASCADE,\n    )\n</code></pre> <p>When accessing attributes of this model at runtime, the database type is mapped to a Python type:</p> <pre><code>&gt;&gt;&gt; type(blog_post.name)\n#&gt; &lt;class 'str'&gt;\n&gt;&gt;&gt; blog_post.blog\n#&gt; &lt;Blog: My blog&gt;\n</code></pre> <p>However, there is currently no way to describe the type of <code>blog_post.post</code> using native typing features (as it is being referenced as a string to avoid circular imports).</p> <p>To overcome this issue, a mypy plugin is provided, that will make use of your project settings to discover the available models, so that mypy can understand string references, amongst other features.</p>"},{"location":"context/#the-drawbacks-of-using-the-mypy-plugin","title":"The drawbacks of using the mypy plugin","text":"<p>Using a type checker can be beneficial to catch errors that would usually result in unhandled exceptions at runtime. To get immediate feedback on these errors along with the inferred types of your code, the type checker can be hooked up in your IDE via a LSP integration (for VSCode users, this is what Pylance is essentially doing).</p> <p>Does this mean we can get all the nice auto-completions and features provided by mypy and the Django plugin?</p> <p>Not really. While LSP implementations for mypy are available, they seem to be lacking important features that you would expect in an IDE. You do get the correct types from the mypy plugin, but you are missing all the highlights/auto-completions:</p> <p> </p> The revealed type by Mypy is correct, but no auto-completion is provided on the 'blog' argument"},{"location":"context/#using-customized-stubs-for-your-project","title":"Using customized stubs for your project","text":"<p>To overcome this issue, we need to find a solution that would ideally:</p> <ul> <li>Be agnostic of any type checker, that is only using the existing Python typing logic.</li> <li>Avoid having to manually annotate your code, if possible.</li> </ul> <p><code>django-autotyping</code> will take advantage of the ability to use a custom type stubs directory (you might need to configure your type checker), where a customized copy of <code>django-stubs</code> will be created. Because <code>django-autotyping</code> knows the current state of your application (e.g. the available models, views), it will generate additional overloads when possible, matching string references to your models for example.</p> Example <p>A smart feature available in type checkers is to add overloads to the <code>__init__</code> method of a class to influence the constructed object type. With the following:</p> <pre><code># __set__ value type\n_ST = TypeVar(\"_ST\")\n# __get__ return type\n_GT = TypeVar(\"_GT\")\n\nclass ForeignKey(Generic[_ST, _GT]):\n    @overload\n    def __init__(\n        self: ForeignKey[Blog | Combinable | None, Blog | None],\n        to: Literal[\"Blog\", \"blogs.Blog\"],\n        ...,\n        null: Literal[True],\n        ...\n    ): ...\n    @overload\n    def __init__(\n        self: ForeignKey[Blog | Combinable, Blog],\n        to: Literal[\"Blog\", \"blogs.Blog\"],\n        ...,\n        null: Literal[False] = ...,\n        ...\n    ): ...\n</code></pre> <p>Without going into the details of the Django field descriptors, this enables the following:</p> <pre><code>class BlogPost(models.Model):\n    blog = models.ForeignKey(\n        to=\"Blog\",\n        on_delete=models.CASCADE,\n    )\n\nBlogPost().blog  # typed as \"Blog\", or \"Blog | None\" if null was set to `True`\n</code></pre> <p>You get:</p> <ul> <li>Complete support for typed foreign fields, without any manual annotations</li> <li>Support for nullable fields</li> <li>Complete IDE support!</li> </ul>"},{"location":"context/#dynamic-stubs-dont-solve-everything","title":"Dynamic stubs don't solve everything","text":"<p>Even if the generated dynamic stubs cover a lot of cases, explicit annotations are still required sometimes. Consider the use case of reverse relationships:</p> <pre><code># On a blog instance, the related blog posts can be accessed:\nblog.blogpost_set  # Or with a custom attribute name, by specifying `related_name`\n</code></pre> <p>To make the type checker aware of this attribute, you have to explicitly annotate the <code>Blog</code> class:</p> <pre><code>class Blog(models.Model):\n    # `BlogPost` also needs to be imported, and the `Manager` class\n    # used might differ:\n    blogpost_set: Manager[BlogPost]\n</code></pre> <p>For these kind of use cases, <code>django-autotyping</code> provides a <code>add_type_hints</code> command, that will take care of automatically add type hints to your source code.</p>"},{"location":"api/typing/","title":"Typing","text":""},{"location":"api/typing/#django_autotyping.typing.AutotypingSettingsDict","title":"<code>AutotypingSettingsDict</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>A utility <code>TypedDict</code> to be used in user code settings.</p> <pre><code>AUTOTYPING: AutotypingSettingsDict = {\n    \"IGNORE\": [\"DJA001\"],\n    ...\n}\n</code></pre> Source code in <code>src/django_autotyping/typing.py</code> <pre><code>class AutotypingSettingsDict(TypedDict, total=False):\n    \"\"\"A utility `TypedDict` to be used in user code settings.\n\n    ```python\n    AUTOTYPING: AutotypingSettingsDict = {\n        \"IGNORE\": [\"DJA001\"],\n        ...\n    }\n    ```\n    \"\"\"\n\n    IGNORE: list[RulesT]\n    \"\"\"A list of ignored rules.\"\"\"\n\n    STUBS_GENERATION: StubsGenerationSettingsDict\n    \"\"\"Stub related settings.\"\"\"\n\n    CODE_GENERATION: CodeGenerationSettingsDict\n    \"\"\"Code generation related settings.\"\"\"\n</code></pre>"},{"location":"api/dynamic_stubs/rules/","title":"Rules","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.forward_relation_overload_codemod.ForwardRelationOverloadCodemod","title":"<code>ForwardRelationOverloadCodemod</code>","text":"<p>A codemod that will add overloads to the <code>__init__</code> methods of related fields.</p> <p>Rule identifier: <code>DJAS001</code>.</p> <p>Related settings:</p> <ul> <li><code>ALLOW_PLAIN_MODEL_REFERENCES</code></li> <li><code>ALLOW_NONE_SET_TYPE</code></li> </ul> <p>This will provide auto-completion when using <code>ForeignKey</code>, <code>OneToOneField</code> and <code>ManyToManyField</code> with string references to a model, and accurate type checking when accessing the field attribute from a model instance.</p> <pre><code>class MyModel(models.Model):\n    field = models.ForeignKey(\n        \"myapp.Other\",\n        on_delete=models.CASCADE,\n    )\n    nullable = models.OneToOneField(\n        \"myapp.Other\",\n        on_delete=models.CASCADE,\n        null=True,\n    )\nreveal_type(MyModel().field)  # Revealed type is \"Other\"\nreveal_type(MyModel().nullable)  # Revealed type is \"Other | None\"\n</code></pre> Implementation <p>The following is a snippet of the produced overloads:</p> <pre><code>class ForeignKey(ForeignObject[_ST, _GT]):\n    # For each model, will add two overloads:\n    # - 1st: `null: Literal[True]`, which will parametrize `ForeignKey` types as `Optional`.\n    # - 2nd: `null: Literal[False] = ...` (the default).\n    # `to` is annotated as a `Literal`, with two values: {app_label}.{model_name} and {model_name}.\n    @overload\n    def __init__(\n        self: ForeignKey[MyModel | Combinable | None, MyModel | None],\n        to: Literal[\"MyModel\", \"myapp.MyModel\"],\n        ...\n    ) -&gt; None: ...\n</code></pre>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.forward_relation_overload_codemod.ForwardRelationOverloadCodemod.STUB_FILES","title":"<code>STUB_FILES = {'db/models/fields/related.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.create_overload_codemod.CreateOverloadCodemod","title":"<code>CreateOverloadCodemod</code>","text":"<p>A codemod that will add overloads to the <code>create</code> and <code>acreate</code> methods.</p> <p>Rule identifier: <code>DJAS002</code>.</p> <p>Related settings:</p> <ul> <li><code>MODEL_FIELDS_OPTIONAL</code>.</li> </ul> <pre><code>MyModel.objects.create(...)  # Signature is provided.\n</code></pre> Implementation <p>This codemod makes use of the PEP 692. If your type checker/LSP supports it, documentation is provided for each field if <code>help_text</code> was set.</p>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.create_overload_codemod.CreateOverloadCodemod.STUB_FILES","title":"<code>STUB_FILES = {'db/models/manager.pyi', 'db/models/query.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.model_init_overload_codemod.ModelInitOverloadCodemod","title":"<code>ModelInitOverloadCodemod</code>","text":"<p>A codemod that will add overloads to the <code>Model.__init__</code> method.</p> <p>Rule identifier: <code>DJAS003</code>.</p> <p>Related settings:</p> <ul> <li><code>MODEL_FIELDS_OPTIONAL</code>.</li> </ul> <pre><code>MyModel(...)  # Signature is provided.\n</code></pre> Implementation <p>This codemod makes use of the PEP 692. If your type checker/LSP supports it, documentation is provided for each field if <code>help_text</code> was set.</p>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.model_init_overload_codemod.ModelInitOverloadCodemod.STUB_FILES","title":"<code>STUB_FILES = {'db/models/base.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.get_model_overload_codemod.GetModelOverloadCodemod","title":"<code>GetModelOverloadCodemod</code>","text":"<p>A codemod that will add overloads to the <code>apps.get_model</code> method.</p> <p>Rule identifier: <code>DJAS010</code>.</p> <pre><code>reveal_type(apps.get_model(\"app_name.ModelName\"))  # Revealed type is \"type[ModelName]\"\nreveal_type(apps.get_model(\"app_name\", \"ModelName\"))  # Revealed type is \"type[ModelName]\"\n</code></pre>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.get_model_overload_codemod.GetModelOverloadCodemod.STUB_FILES","title":"<code>STUB_FILES = {'apps/registry.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.auth_functions_codemod.AuthFunctionsCodemod","title":"<code>AuthFunctionsCodemod</code>","text":"<p>A codemod that will add a custom return type to the to auth related functions.</p> <p>The following functions are affected:</p> <ul> <li><code>authenticate</code></li> <li><code>login</code></li> <li><code>get_user_model</code></li> <li><code>get_user</code></li> <li><code>update_session_auth_hash</code></li> </ul> <p>Rule identifier: <code>DJAS011</code>.</p> <pre><code>from django.contrib.auth import authenticate, get_user_model, get_user\n\nreveal_type(authenticate(rq, **creds))  # Revealed type is \"YourCustomUser | None\"\nreveal_type(get_user_model())  # Revealed type is \"type[YourCustomUser]\"\nreveal_type(get_user(rq))  # Revealed type is \"YourCustomUser | AnonymousUser\"\n</code></pre>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.auth_functions_codemod.AuthFunctionsCodemod.STUB_FILES","title":"<code>STUB_FILES = {'contrib/auth/__init__.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.reverse_overload_codemod.ReverseOverloadCodemod","title":"<code>ReverseOverloadCodemod</code>","text":"<p>A codemod that will add overloads to the <code>reverse</code> function.</p> <p>Rule identifier: <code>DJAS015</code>.</p> <p>Related settings:</p> <ul> <li><code>ALLOW_REVERSE_ARGS</code>.</li> </ul> <pre><code>reverse(\"my-view-name\", kwargs={...})  # `kwargs` is typed with a `TypedDict`, providing auto-completion.\n</code></pre>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.reverse_overload_codemod.ReverseOverloadCodemod.STUB_FILES","title":"<code>STUB_FILES = {'urls/base.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.settings_codemod.SettingCodemod","title":"<code>SettingCodemod</code>","text":"<p>A codemod that will add typing to the Django settings object.</p> <p>Depending on the Django version being used when running the stubs generation, the available settings might differ. The <code>@deprecated</code> decorator will be used if necessary, thus making your type checker aware of the deprecation notice.</p> <p>Rule identifier: <code>DJAS016</code>.</p> <pre><code>from django.conf import settings\n\nreveal_type(settings.ADMINS)  # Revealed type is \"list[tuple[str, str]]\"\nreveal_type(settings.CUSTOM_SETTING)  # Revealed type is \"str\"\nreveal_type(settings.USE_DEPRECATED_PYTZ)  # Will be marked as deprecated by the type checker.\n</code></pre> <p>Experimental</p> <p>Type hints might not reflect the actual type being used at runtime. For Django settings, all the possible types are taken into account (e.g. the <code>EMAIL_TIMEOUT</code> setting might be set to <code>10</code>, but as the default value is <code>None</code>, the reflected type hint will be <code>int | None</code>).</p> <p>For custom settings, only simple types are inferred. See this issue for more details.</p>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.settings_codemod.SettingCodemod.STUB_FILES","title":"<code>STUB_FILES = {'conf/__init__.pyi'}</code>","text":""},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.template_loading_codemod.TemplateLoadingCodemod","title":"<code>TemplateLoadingCodemod</code>","text":"<p>A codemod that will add overloads for template loading functions:</p> <ul> <li><code>get_template</code></li> <li><code>select_template</code></li> <li><code>render_to_string</code></li> </ul> <p>Rule identifier: <code>DJAS017</code>.</p> <pre><code>from django.template.loader import get_template\n\nget_template(\"a_template.html\")  # 'a_template.html' can be from any engine\nget_template(\"a_django_template.html\", using=\"django\")\nget_template(\"not_a_jinja2_template.html\", using=\"my_jinja2_engine\")  # Type error\n</code></pre> <p>Limited support</p> <p>Engines other that Django and custom loaders are not supported yet.</p>"},{"location":"api/dynamic_stubs/rules/#django_autotyping.stubbing.codemods.template_loading_codemod.TemplateLoadingCodemod.STUB_FILES","title":"<code>STUB_FILES = {'template/loader.pyi'}</code>","text":""},{"location":"api/explicit_type_hints/rules/","title":"Rules","text":""},{"location":"api/explicit_type_hints/rules/#django_autotyping.codemodding.codemods.forward_relation_typing_codemod.ForwardRelationTypingCodemod","title":"<code>ForwardRelationTypingCodemod</code>","text":"<p>A codemod that will add type annotations to forward relations.</p> <p>Rule identifier: <code>DJA001</code>.</p> <p>Outdated</p> <p>This codemod is outdated and does not play well with <code>django-stubs</code>. Instead, it is recommended to use the corresponding dynamic stub rule (<code>DJAS001</code>).</p> <pre><code>from typing import TYPE_CHECKING\n\nfrom django.db import models\n\n# Model is imported in an `if TYPE_CHECKING` block if `--type-checking-block` is used.\nif TYPE_CHECKING:\n    # Related model is imported from the corresponding apps models module:\n    from myproject.reporters.models import Reporter\n\n\nclass Article(models.Model):\n    # If the field supports `__class_getitem__` at runtime, it is parametrized directly:\n    reporter = models.ForeignKey[\"Reporter\"](\n        \"reporters.Reporter\",\n        on_delete=models.CASCADE,\n    )\n\n    # Otherwise, an explicit annotation is used. No unnecessary import if model is in the same file.\n    article_version: \"models.OneToOneField[ArticleVersion]\" = models.OneToOneField(\n        \"ArticleVersion\",\n        on_delete=models.CASCADE,\n    )\n</code></pre>"},{"location":"usage/dynamic_stubs/","title":"Dynamic stubs","text":"<p><code>django-autotyping</code> can generate customized type stubs depending on the current state of your Django project:</p> <pre><code>python manage.py generate_stubs --local-stubs-dir typings/ --ignore DJAS001\n</code></pre>"},{"location":"usage/dynamic_stubs/#available-rules","title":"Available rules","text":"<p>The following is a list of the available rules related to dynamic stubs:</p> <ul> <li><code>DJAS001</code>: add overloads to the <code>__init__</code> methods of related fields.</li> <li><code>DJAS002</code>: Add overloads to the <code>create</code> and <code>acreate</code> methods.</li> <li><code>DJAS003</code>: Add overloads to the <code>Model.__init__</code> method.</li> <li><code>DJAS010</code>: Add overloads to the <code>apps.get_model</code> method.</li> <li><code>DJAS011</code>: Add a custom return type to the to auth related functions.</li> <li><code>DJAS015</code>: Add overloads to the <code>reverse</code> function.</li> <li><code>DJAS016</code>: Add typing to the Django settings object.</li> <li><code>DJAS017</code>: Add overloads for template loading functions.</li> </ul>"},{"location":"usage/dynamic_stubs/#type-checker-configuration","title":"Type checker configuration","text":"<p>Before making use of this feature, you must configure your type checker to discover your custom stubs:</p> <ul> <li><code>pyright</code>: will look for the <code>typings/</code> directory by default (see the <code>stubPath</code> configuration option).</li> <li><code>mypy</code>: configurable via the <code>mypy_path</code> value (or use the <code>MYPY_PATH</code> environment variable).</li> </ul>"},{"location":"usage/dynamic_stubs/#configuration","title":"Configuration","text":"<p>This section describes the available configuration options for stubs generation. These values must be set as a dictionary under the <code>STUBS_GENERATION</code> key:</p> <pre><code>AUTOTYPING = {\n    \"STUBS_GENERATION\": {\n        \"LOCAL_STUBS_DIR\": Path(...),\n    }\n}\n</code></pre> <p>Configuration for dynamic stubs generation.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.LOCAL_STUBS_DIR","title":"<code>LOCAL_STUBS_DIR: Path | None = None</code>","text":"<p>The directory of the local type stubs. If not set, this setting must be set as a CLI argument.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.SOURCE_STUBS_DIR","title":"<code>SOURCE_STUBS_DIR: Path | None = None</code>","text":"<p>The directory of the source <code>django-stubs</code> to be used. Will default to the first entry in site packages.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.ALLOW_PLAIN_MODEL_REFERENCES","title":"<code>ALLOW_PLAIN_MODEL_REFERENCES: bool = True</code>","text":"<p>Whether string references in the form of <code>{model_name}</code> should be generated in overloads.</p> <p>If set to <code>True</code>, both <code>{model_name}</code> and <code>{app_label}.{model_name}</code> are allowed (unless the model name has a duplicate in a different app).</p> <p>Affected rules: <code>DJAS001</code>.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.ALLOW_NONE_SET_TYPE","title":"<code>ALLOW_NONE_SET_TYPE: bool = False</code>","text":"<p>Whether to allow having the <code>__set__</code> type variable set to <code>None</code>, even if the field is not nullable.</p> <p>While Django allows setting most model instance fields to any value (before saving), it is generally a bad practice to do so. However, it might be beneficial to allow <code>None</code> to be set temporarly.</p> <p>This also works for foreign fields, where unlike standard fields, the Django descriptor used only allows model instances and <code>None</code> to be set.</p> <p>Affected rules: <code>DJAS001</code>.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.MODEL_FIELDS_OPTIONAL","title":"<code>MODEL_FIELDS_OPTIONAL: bool = True</code>","text":"<p>Whether all model fields should be considered optional when creating model instances.</p> <p>This affects the following signatures:</p> <ul> <li><code>Manager.create/acreate</code></li> <li><code>__init__</code> methods of models</li> </ul> <p>A lot can happen behind the scenes when instantiating models. Even if a field doesn't have a default value provided, the database could have triggers implemented that would provide one. This is why, by default, this configuration attribute defaults to <code>True</code>. If set to <code>False</code>, <code>django-autotyping</code> will try its best to determine required fields, namely by checking if:</p> <ul> <li>the field can be <code>null</code> or <code>blank</code></li> <li>the field is a primary key</li> <li>the field has a default or a database default value set</li> <li>the field is a subclass of <code>DateField</code> and has   <code>auto_now</code> or <code>auto_now_add</code>   set to <code>True</code>.</li> </ul> <p>Affected rules: <code>DJAS002</code>, <code>DJAS003</code>.</p>"},{"location":"usage/dynamic_stubs/#django_autotyping.app_settings.StubsGenerationSettings.ALLOW_REVERSE_ARGS","title":"<code>ALLOW_REVERSE_ARGS: bool = False</code>","text":"<p>Whether type checking should be added to the <code>args</code> argument of <code>reverse</code>.</p> <p>By default, this is set to <code>False</code> to avoid having too many overloads being generated. Moreover, only tuples can be type checked, and most people are using lists for this argument. Instead, it is recommended to use the <code>kwargs</code> argument.</p> <p>Affected rules: <code>DJAS015</code>.</p>"},{"location":"usage/explicit_type_hints/","title":"Explicit type hints","text":"<p>There are some cases where generating custom type stubs is not enough. In such cases, it might be required to add some explicit type annotations to your code.</p> <p>Fortunately, <code>django-autotyping</code> can automatically add these type hints in some places.</p> <pre><code>python manage.py add_type_hints --project-dir src/ --diff --ignore DJA001\n</code></pre> <p>Still work in progress</p> <p>This functionality is still work in progress.</p>"},{"location":"usage/explicit_type_hints/#available-rules","title":"Available rules","text":"<ul> <li><code>DJA001</code>: Add type annotations to forward relations.</li> </ul>"},{"location":"usage/explicit_type_hints/#configuration","title":"Configuration","text":"<p>This section describes the available configuration options for stubs generation. These values must be set as a dictionary under the <code>CODE_GENERATION</code> key:</p> <pre><code>AUTOTYPING = {\n    \"STUBS_GENERATION\": {\n        \"PROJECT_DIR\": Path(...),\n    }\n}\n</code></pre> <p>Configuration for adding type annotations to Django user code.</p>"},{"location":"usage/explicit_type_hints/#django_autotyping.app_settings.CodeGenerationSettings.PROJECT_DIR","title":"<code>PROJECT_DIR: Path | None = None</code>","text":"<p>The directory of the project, where code modifications should be applied.</p>"},{"location":"usage/explicit_type_hints/#django_autotyping.app_settings.CodeGenerationSettings.DIFF","title":"<code>DIFF: bool = False</code>","text":"<p>Show changes to be applied instead of modifying existing files.</p>"},{"location":"usage/explicit_type_hints/#django_autotyping.app_settings.CodeGenerationSettings.TYPE_CHECKING_BLOCK","title":"<code>TYPE_CHECKING_BLOCK: bool = True</code>","text":"<p>Whether newly added imports should be in an <code>if TYPE_CHECKING</code> block (avoids circular imports).</p>"},{"location":"usage/explicit_type_hints/#django_autotyping.app_settings.CodeGenerationSettings.ASSUME_CLASS_GETITEM","title":"<code>ASSUME_CLASS_GETITEM: bool = False</code>","text":"<p>Whether generic classes in stubs files but not at runtime should be assumed to have a <code>__class_getitem__</code> method. This can be achieved by using <code>django-stubs-ext</code> or manually.</p> <p>Affected rules: <code>DJA001</code>.</p>"}]}